#include "MAIN.H"
#include "Tools.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void CAN1_vInit(void)
{

  C1CSR          =  0x0041;      // set CAN1 INIT and CCE

  ///  - input clock is divided by 2
  ///  - baudrate = 1.000 Mbaud
  ///  - there are 5 time quanta before sample point
  ///  - there are 4 time quanta after sample point
  ///  - the (re)synchronization jump width is 2 time quanta

  C1BTR          =  0x3440;      // set CAN1 bit timing register

  C1GMS          =  0xE0FF;      // set CAN1 global mask short register

  C1UGML         =  0xFFFF;      // set CAN1 upper global mask long register

  C1LGML         =  0xF8FF;      // set CAN1 lower global mask long register

  ///  -----------------------------------------------------------------------
  ///  ---------------- Configure Message Object 1 --------------------------
  ///  -----------------------------------------------------------------------
  ///  - message object 1 is valid

  CAN1_OBJ[0].MCR  =  0x5695;    // set CAN1 message control register

  ///  - message direction is transmit
  ///  - standard 11-bit identifier
  ///  - 8 valid data bytes

  CAN1_OBJ[0].MCFG  =  0x88;     // set CAN1 message configuration register
  CAN1_OBJ[0].UAR  =  0x0000;    // set CAN1 upper arbitration register
  CAN1_OBJ[0].LAR  =  0x0000;    // set CAN1 lower arbitration register

  CAN1_OBJ[0].Data[0]  =  0xF5;  // set data byte 0
  CAN1_OBJ[0].Data[1]  =  0x55;  // set data byte 1
  CAN1_OBJ[0].Data[2]  =  0x00;  // set data byte 2
  CAN1_OBJ[0].Data[3]  =  0x00;  // set data byte 3
  CAN1_OBJ[0].Data[4]  =  0x00;  // set data byte 4
  CAN1_OBJ[0].Data[5]  =  0x00;  // set data byte 5
  CAN1_OBJ[0].Data[6]  =  0x00;  // set data byte 6
  CAN1_OBJ[0].Data[7]  =  0x00;  // set data byte 7

  ///  -----------------------------------------------------------------------
  ///  ---------------- Configure Message Object 2 --------------------------
  ///  -----------------------------------------------------------------------
  ///  - message object 2 is not valid
  CAN1_OBJ[1].MCR  =  0x5999;    // set CAN1 message control register

  ///  - message direction is RECEIVE!!!
  ///  - standard 11-bit identifier
  ///  - 8 valid data bytes

  CAN1_OBJ[1].MCFG  =  0x80;     // set CAN1 message configuration register
  CAN1_OBJ[1].UAR  =  0x0000;    // set CAN1 upper arbitration register
  CAN1_OBJ[1].LAR  =  0x0000;    // set CAN1 lower arbitration register

  CAN1_OBJ[1].Data[0]  =  0xF5;  // set data byte 0
  CAN1_OBJ[1].Data[1]  =  0x50;  // set data byte 1
  CAN1_OBJ[1].Data[2]  =  0x00;  // set data byte 2
  CAN1_OBJ[1].Data[3]  =  0x00;  // set data byte 3
  CAN1_OBJ[1].Data[4]  =  0x00;  // set data byte 4
  CAN1_OBJ[1].Data[5]  =  0x00;  // set data byte 5
  CAN1_OBJ[1].Data[6]  =  0x00;  // set data byte 6
  CAN1_OBJ[1].Data[7]  =  0x00;  // set data byte 7

  CAN1_OBJ[2].MCR  =  0x5555;
  CAN1_OBJ[3].MCR  =  0x5555;
  CAN1_OBJ[4].MCR  =  0x5555;
  CAN1_OBJ[5].MCR  =  0x5555;
  CAN1_OBJ[6].MCR  =  0x5555; 
  CAN1_OBJ[7].MCR  =  0x5555;
  CAN1_OBJ[8].MCR  =  0x5555;
  CAN1_OBJ[9].MCR  =  0x5555; 
  CAN1_OBJ[10].MCR  =  0x5555;
  CAN1_OBJ[11].MCR  =  0x5555;
  CAN1_OBJ[12].MCR  =  0x5555;
  CAN1_OBJ[13].MCR  =  0x5555;
  CAN1_OBJ[14].MCR  =  0x5555;   

  ///  -----------------------------------------------------------------------
  ///  Configuration of the used CAN1 Timer Port Pins:
  ///  -----------------------------------------------------------------------
  ///  - P4.5 is used for CAN1 Interface Input (CAN1_RxD)
  ///  - P4.6 is used for CAN1 Interface Output (CAN1_TxD)

  DP4  = (DP4  & ~(uword)0x0040) | 0x0040;    //set direction register

  C1PCIR         = (C1PCIR & ~(uword)0x0700) | 0x0000; // set CAN1 interface 
                                                       // port controll 
                                                       // register

  ///  -----------------------------------------------------------------------
  ///  Configuration of the used CAN1 Interrupts:
  ///  -----------------------------------------------------------------------
  ///  - CAN1 service request node configuration:
  ///  - CAN1 interrupt priority level (ILVL) = 9
  ///  - CAN1 interrupt group level (GLVL) = 2

  XP0IC          =  0x0066;     

  /// ------------ CAN1 Control/Status Register --------------
  ///  - reset CCE and INIT
  ///  - enable interrupt generation from CAN1 Modul

  C1CSR          =  0x0002;      // set CAN1 control satatus register

} 


void handle_incoming(void);

void CAN1_viCAN1(void) interrupt XP0INT
{
	unsigned int to_return = 0;
	uword uwIntID;
	uwIntID = C1PCIR & 0x00ff;
	switch (uwIntID & 0x00ff){
		// if the interrupt is generated by Message Object 2:
		case 4: 
			// reset the interrupt bit
			CAN1_OBJ[1].MCR = 0xfffd; 

			// if there's new data, we can assume that the interrupt is a result of new data coming in
			if ((CAN1_OBJ[1].MCR & 0x0300) == 0x0200) // if NEWDAT set
			{
				// if the CPU thinks that a CAN object has been overwritten before the code has had a chance to process the last one:
				if ((CAN1_OBJ[1].MCR & 0x0c00) == 0x0800) // if MSGLST set
				{
					// Indicates that the CAN1 controller has stored a new
					// message into this object, while NEWDAT was still set,
					// ie. the previously stored message is lost.
					CAN1_OBJ[1].MCR = 0xf7ff; // reset MSGLST
					IO_vWritePort(P2,0x8181);
				}

				// handle an incoming signal																																	 	
				handle_incoming();										

			}
		break;
		default:
			// currently ignore any other situation
		break;
	}
}

#define RESPONSE_CURRENT_BRIGHTNESS 4

void handle_incoming(void) {
	// if the remote device tries to tell us what the brightness currently is:
 	if(CAN1_OBJ[1].Data[0] == RESPONSE_CURRENT_BRIGHTNESS) {
		char out[3] = "xxx";
		// ASSERT: We know that the (or, for now, 'a') remote device is trying to tell us what the brightness is
		sendString("The brightness is: ");
		sprintf(out, "%d", CAN1_OBJ[1].Data[1]);
		sendString(out);
		receiveCurrentBrightness(CAN1_OBJ[1].Data[1]);

	}else {
		// I really hope this doesn't happen: maybe do something to indicate an error
		sendString("Received an unrecognised frame from the remote device.");
	}
}

// dave-generated code to tell the CAN controller to send the byte
void CAN1_vTransmit(ubyte ubObjNr)
{
  CAN1_OBJ[ubObjNr - 1].MCR = 0xe7ff;  // set TXRQ,reset CPUUPD
}

/**
 * procedure to send a opcode/operand pair as used in the application layer
 * @param	unsigned char	opcode	the opcode to be sent
 * @param	unsigned char	operand	the operand to pair with the opcode
 */
void CAN1_SendShort(unsigned char opcode, unsigned char operand) {
	// load the opcode into the first byte
	CAN1_OBJ[0].Data[0] = opcode;

	// load the operand into the second byte
	CAN1_OBJ[0].Data[1] = operand;

	// transmit the frame
	CAN1_vTransmit(1);
}
